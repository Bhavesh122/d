DomainController.java

package com.rwtool.controller;

import com.rwtool.model.Domain;
import com.rwtool.service.DomainService;
import com.rwtool.service.AuditLogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/domains")
@CrossOrigin(origins = "http://localhost:3000")
public class DomainController {

    @Autowired
    private DomainService domainService;
    
    @Autowired
    private AuditLogService auditLogService;

    @GetMapping
    public ResponseEntity<List<Domain>> getAllDomains() {
        try {
            List<Domain> domains = domainService.getAllDomains();
            return ResponseEntity.ok(domains);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<Domain> getDomainById(@PathVariable String id) {
        try {
            Domain domain = domainService.getDomainById(id);
            return ResponseEntity.ok(domain);
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    @PostMapping
    public ResponseEntity<?> addDomain(@RequestBody Domain domain) {
        try {
            Domain savedDomain = domainService.addDomain(domain);
            auditLogService.logActivity(
                "system", // TODO: Get actual admin email from security context
                "Admin",
                "DOMAIN_ADDED",
                "Added new domain: " + savedDomain.getName(),
                "success"
            );
            return ResponseEntity.status(HttpStatus.CREATED).body(savedDomain);
        } catch (RuntimeException e) {
            auditLogService.logActivity(
                "system",
                "Admin",
                "DOMAIN_ADD_FAILED",
                "Failed to add domain: " + e.getMessage(),
                "failed"
            );
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateDomain(@PathVariable String id, @RequestBody Domain domain) {
        try {
            Domain updatedDomain = domainService.updateDomain(id, domain);
            auditLogService.logActivity(
                "system", // TODO: Get actual admin email from security context
                "Admin",
                "DOMAIN_UPDATED",
                "Updated domain: " + updatedDomain.getName(),
                "success"
            );
            return ResponseEntity.ok(updatedDomain);
        } catch (RuntimeException e) {
            auditLogService.logActivity(
                "system",
                "Admin",
                "DOMAIN_UPDATE_FAILED",
                "Failed to update domain: " + e.getMessage(),
                "failed"
            );
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteDomain(@PathVariable String id) {
        try {
            // Get domain name before deletion for audit log
            Domain domain = domainService.getDomainById(id);
            String domainName = domain.getName();
            domainService.deleteDomain(id);
            auditLogService.logActivity(
                "system", // TODO: Get actual admin email from security context
                "Admin",
                "DOMAIN_DELETED",
                "Deleted domain: " + domainName,
                "success"
            );
            return ResponseEntity.ok().build();
        } catch (RuntimeException e) {
            auditLogService.logActivity(
                "system",
                "Admin",
                "DOMAIN_DELETE_FAILED",
                "Failed to delete domain: " + e.getMessage(),
                "failed"
            );
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        }
    }
}


Subscritpion request controller.java

package com.rwtool.controller;

import com.rwtool.dto.ApprovalDecisionDTO;
import com.rwtool.dto.SubscriptionRequestDTO;
import com.rwtool.model.SubscriptionRequest;
import com.rwtool.service.SubscriptionRequestService;
import com.rwtool.service.AuditLogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/subscriptions")
@CrossOrigin(origins = "http://localhost:3000")
public class SubscriptionRequestController {

    @Autowired
    private SubscriptionRequestService subscriptionRequestService;
    
    @Autowired
    private AuditLogService auditLogService;

    // Get all subscription requests (for admin)
    @GetMapping
    public ResponseEntity<List<SubscriptionRequest>> getAllRequests() {
        try {
            List<SubscriptionRequest> requests = subscriptionRequestService.getAllRequests();
            return ResponseEntity.ok(requests);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Get pending requests (for admin)
    @GetMapping("/pending")
    public ResponseEntity<List<SubscriptionRequest>> getPendingRequests() {
        try {
            List<SubscriptionRequest> requests = subscriptionRequestService.getPendingRequests();
            return ResponseEntity.ok(requests);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Get requests by user email (for user dashboard)
    @GetMapping("/user/{email}")
    public ResponseEntity<List<SubscriptionRequest>> getRequestsByUser(@PathVariable String email) {
        try {
            List<SubscriptionRequest> requests = subscriptionRequestService.getRequestsByUser(email);
            return ResponseEntity.ok(requests);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // Get request by ID
    @GetMapping("/{id}")
    public ResponseEntity<SubscriptionRequest> getRequestById(@PathVariable String id) {
        try {
            SubscriptionRequest request = subscriptionRequestService.getRequestById(id);
            return ResponseEntity.ok(request);
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    // Create new subscription request (for users)
    @PostMapping
    public ResponseEntity<?> createRequest(@RequestBody SubscriptionRequestDTO requestDTO) {
        try {
            SubscriptionRequest request = subscriptionRequestService.createRequest(requestDTO);
            auditLogService.logActivity(
                request.getUserEmail(),
                "Subscriber",
                "SUBSCRIPTION_REQUESTED",
                "User requested subscription for domain: " + request.getDomainName(),
                "success"
            );
            return ResponseEntity.status(HttpStatus.CREATED).body(request);
        } catch (RuntimeException e) {
            auditLogService.logActivity(
                requestDTO.getUserEmail() != null ? requestDTO.getUserEmail() : "unknown",
                "Subscriber",
                "SUBSCRIPTION_REQUEST_FAILED",
                "Failed to create subscription request: " + e.getMessage(),
                "failed"
            );
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    // Approve or reject request (for admin)
    @PutMapping("/{id}/review")
    public ResponseEntity<?> reviewRequest(
            @PathVariable String id,
            @RequestBody ApprovalDecisionDTO decision) {
        try {
            SubscriptionRequest request = subscriptionRequestService.processRequest(id, decision);
            return ResponseEntity.ok(request);
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    // Approve request (for admin)
    @PutMapping("/{id}/approve")
    public ResponseEntity<?> approveRequest(@PathVariable String id) {
        try {
            SubscriptionRequest request = subscriptionRequestService.approveRequest(id);
            // TODO: Get actual admin email from security context
            auditLogService.logActivity(
                "system",
                "Admin",
                "USER_APPROVED",
                "Approved subscription request for " + request.getUserEmail(),
                "success"
            );
            return ResponseEntity.ok(request);
        } catch (RuntimeException e) {
            auditLogService.logActivity(
                "system",
                "Admin",
                "USER_APPROVAL_FAILED",
                "Failed to approve subscription request: " + e.getMessage(),
                "failed"
            );
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    // Reject request (for admin)
    @PutMapping("/{id}/reject")
    public ResponseEntity<?> rejectRequest(
            @PathVariable String id,
            @RequestBody ApprovalDecisionDTO decision) {
        try {
            String reason = decision.getRejectionReason();
            SubscriptionRequest request = subscriptionRequestService.rejectRequest(id, reason);
            // TODO: Get actual admin email from security context
            auditLogService.logActivity(
                "system",
                "Admin",
                "USER_REJECTED",
                "Rejected subscription request for " + request.getUserEmail() + ". Reason: " + reason,
                "success"
            );
            return ResponseEntity.ok(request);
        } catch (RuntimeException e) {
            auditLogService.logActivity(
                "system",
                "Admin",
                "USER_REJECTION_FAILED",
                "Failed to reject subscription request: " + e.getMessage(),
                "failed"
            );
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    // Cancel request (for users)
    @DeleteMapping("/{id}/cancel")
    public ResponseEntity<?> cancelRequest(
            @PathVariable String id,
            @RequestParam String userEmail) {
        try {
            subscriptionRequestService.cancelRequest(id, userEmail);
            return ResponseEntity.ok().build();
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
        }
    }

    // Get dashboard statistics (for admin)
    @GetMapping("/stats")
    public ResponseEntity<?> getDashboardStats() {
        try {
            List<SubscriptionRequest> allRequests = subscriptionRequestService.getAllRequests();
            
            long totalRequests = allRequests.size();
            long pendingCount = allRequests.stream()
                    .filter(r -> "PENDING".equalsIgnoreCase(r.getStatus()))
                    .count();
            long approvedCount = allRequests.stream()
                    .filter(r -> "APPROVED".equalsIgnoreCase(r.getStatus()))
                    .count();
            long rejectedCount = allRequests.stream()
                    .filter(r -> "REJECTED".equalsIgnoreCase(r.getStatus()))
                    .count();
            
            double approvalRate = totalRequests > 0 
                    ? (approvedCount * 100.0) / (approvedCount + rejectedCount)
                    : 0.0;
            
            java.util.Map<String, Object> stats = new java.util.HashMap<>();
            stats.put("totalRequests", totalRequests);
            stats.put("pendingRequests", pendingCount);
            stats.put("approvedRequests", approvedCount);
            stats.put("rejectedRequests", rejectedCount);
            stats.put("approvalRate", Math.round(approvalRate * 10) / 10.0); // Round to 1 decimal
            
            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

filedownloadcontroller.java

package com.rwtool.controller;

import com.rwtool.service.AuditLogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;

@RestController
@RequestMapping("/api/files")
@CrossOrigin(origins = "http://localhost:3000")
public class FileDownloadController {

    @Value("${app.storage.local.baseDir:}")
    private String localBaseDir;
    
    @Autowired
    private AuditLogService auditLogService;

    /**
     * Download a file from a specific folder
     * @param folder - folder name (e.g., "Finance", "Compliance")
     * @param fileName - file name
     */
    @GetMapping("/download")
    public ResponseEntity<Resource> downloadFile(
            @RequestParam String folder,
            @RequestParam String fileName) {
        
        try {
            // Construct file path: baseDir/reports/folder/fileName
            Path filePath = Paths.get(localBaseDir)
                    .resolve("reports")
                    .resolve(folder)
                    .resolve(fileName)
                    .normalize();
            
            Resource resource = new UrlResource(filePath.toUri());
            
            if (!resource.exists() || !resource.isReadable()) {
                return ResponseEntity.notFound().build();
            }
            
            // Determine content type
            String contentType = "application/octet-stream";
            if (fileName.endsWith(".pdf")) {
                contentType = "application/pdf";
            } else if (fileName.endsWith(".xlsx") || fileName.endsWith(".xls")) {
                contentType = "application/vnd.ms-excel";
            } else if (fileName.endsWith(".docx")) {
                contentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
            } else if (fileName.endsWith(".csv")) {
                contentType = "text/csv";
            }
            
            // Log successful file download
            auditLogService.logActivity(
                "system", // TODO: Get actual user email from security context
                "Subscriber",
                "FILE_DOWNLOADED",
                "Downloaded file: " + fileName + " from folder: " + folder,
                "success"
            );
            
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + fileName + "\"")
                    .body(resource);
                    
        } catch (Exception e) {
            auditLogService.logActivity(
                "system",
                "Subscriber",
                "FILE_DOWNLOAD_FAILED",
                "Failed to download file: " + fileName + " from folder: " + folder + ". Error: " + e.getMessage(),
                "failed"
            );
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Download multiple files as a single ZIP
     * Request body example: { "files": [ {"folder":"Finance","fileName":"a.pdf"}, {"folder":"HR","fileName":"b.pdf"} ], "zipName": "reports.zip" }
     */
    @PostMapping("/download/batch")
    public ResponseEntity<byte[]> downloadBatch(@RequestBody Map<String, Object> body) {
        try {
            @SuppressWarnings("unchecked")
            List<Map<String, String>> files = (List<Map<String, String>>) body.get("files");
            String zipName = (String) body.getOrDefault("zipName", "reports.zip");

            if (files == null || files.isEmpty()) {
                return ResponseEntity.badRequest().build();
            }

            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try (ZipOutputStream zos = new ZipOutputStream(baos)) {
                for (Map<String, String> f : files) {
                    String folder = f.get("folder");
                    String fileName = f.get("fileName");
                    if (folder == null || fileName == null) continue;

                    Path filePath = Paths.get(localBaseDir)
                            .resolve("reports")
                            .resolve(folder)
                            .resolve(fileName)
                            .normalize();
                    Resource resource = new UrlResource(filePath.toUri());
                    if (!resource.exists() || !resource.isReadable()) continue;

                    ZipEntry entry = new ZipEntry(folder + "/" + fileName);
                    zos.putNextEntry(entry);
                    try (InputStream is = resource.getInputStream()) {
                        is.transferTo(zos);
                    }
                    zos.closeEntry();
                }
            }

            byte[] zipBytes = baos.toByteArray();
            return ResponseEntity.ok()
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + zipName + "\"")
                    .header(HttpHeaders.CACHE_CONTROL, "no-cache, no-store, must-revalidate")
                    .header(HttpHeaders.PRAGMA, "no-cache")
                    .header(HttpHeaders.EXPIRES, "0")
                    .body(zipBytes);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
}

pathconfig

package com.rwtool.controller;

import com.rwtool.dto.PageResponse;
import com.rwtool.dto.PathConfigRequest;
import com.rwtool.model.PathConfig;
import com.rwtool.service.PathConfigService;
import com.rwtool.service.AuditLogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/paths")
public class PathConfigController {

    private final PathConfigService service;
    
    @Autowired
    private AuditLogService auditLogService;

    public PathConfigController(PathConfigService service) {
        this.service = service;
    }

    @GetMapping
    public PageResponse<PathConfig> list(@RequestParam(required = false) String search,
                                         @RequestParam(defaultValue = "1") int page,
                                         @RequestParam(defaultValue = "10") int pageSize) {
        return service.list(search, page, pageSize);
    }

    @PostMapping
    public ResponseEntity<PathConfig> create(@RequestBody PathConfigRequest req) {
        try {
            PathConfig created = service.create(req);
            auditLogService.logActivity(
                "system", // TODO: Get actual admin email from security context
                "Admin",
                "PATH_CONFIG_CREATED",
                "Created path configuration: " + created.getPrefix(),
                "success"
            );
            return ResponseEntity.ok(created);
        } catch (Exception e) {
            auditLogService.logActivity(
                "system",
                "Admin",
                "PATH_CONFIG_CREATE_FAILED",
                "Failed to create path configuration: " + e.getMessage(),
                "failed"
            );
            throw e;
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<PathConfig> update(@PathVariable Long id, @RequestBody PathConfigRequest req) {
        try {
            PathConfig updated = service.update(id, req);
            auditLogService.logActivity(
                "system", // TODO: Get actual admin email from security context
                "Admin",
                "PATH_CONFIG_UPDATED",
                "Updated path configuration: " + updated.getPrefix(),
                "success"
            );
            return ResponseEntity.ok(updated);
        } catch (Exception e) {
            auditLogService.logActivity(
                "system",
                "Admin",
                "PATH_CONFIG_UPDATE_FAILED",
                "Failed to update path configuration: " + e.getMessage(),
                "failed"
            );
            throw e;
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<PathConfig> get(@PathVariable Long id) {
        return service.get(id).map(ResponseEntity::ok).orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        try {
            // Get path config before deletion for audit log
            PathConfig pathConfig = service.get(id).orElse(null);
            String prefix = pathConfig != null ? pathConfig.getPrefix() : "Unknown";
            service.delete(id);
            auditLogService.logActivity(
                "system", // TODO: Get actual admin email from security context
                "Admin",
                "PATH_CONFIG_DELETED",
                "Deleted path configuration: " + prefix,
                "success"
            );
            return ResponseEntity.noContent().build();
        } catch (Exception e) {
            auditLogService.logActivity(
                "system",
                "Admin",
                "PATH_CONFIG_DELETE_FAILED",
                "Failed to delete path configuration: " + e.getMessage(),
                "failed"
            );
            throw e;
        }
    }
}

opscontroller.java

package com.rwtool.controller;

import com.rwtool.service.StorageService;
import com.rwtool.service.AuditLogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.HashMap;
import java.util.Map;
import java.util.List;

@RestController
@CrossOrigin(origins = {"http://localhost:3000", "http://127.0.0.1:3000"}, allowCredentials = "false")
@RequestMapping("/api/ops")
public class OpsController {

    private final StorageService storageService;
    
    @Autowired
    private AuditLogService auditLogService;

    public OpsController(StorageService storageService) {
        this.storageService = storageService;
    }

    // Upload a file into the local incoming folder (demo/local mode)
    // form-data: file=<binary>, fileName(optional)="Finance__something.pdf"
    @PostMapping("/import")
    public ResponseEntity<Map<String, Object>> importToIncoming(@RequestParam("file") MultipartFile file,
                                                                @RequestParam(value = "fileName", required = false) String fileName) throws Exception {
        try {
            String savedPath = storageService.saveToIncoming(file, fileName);
            String actualFileName = fileName != null ? fileName : file.getOriginalFilename();
            auditLogService.logActivity(
                "system", // TODO: Get actual ops user email from security context
                "Ops",
                "FILE_UPLOADED",
                "Ops user uploaded file: " + actualFileName,
                "success"
            );
            Map<String, Object> resp = new HashMap<>();
            resp.put("saved", true);
            resp.put("path", savedPath);
            return ResponseEntity.ok(resp);
        } catch (Exception e) {
            String actualFileName = fileName != null ? fileName : (file != null ? file.getOriginalFilename() : "unknown");
            auditLogService.logActivity(
                "system",
                "Ops",
                "FILE_UPLOAD_FAILED",
                "Failed to upload file: " + actualFileName + ". Error: " + e.getMessage(),
                "failed"
            );
            throw e;
        }
    }

    // List files under baseDir/storage (for OPS to choose to import)
    @GetMapping("/storage")
    public ResponseEntity<List<Map<String, Object>>> listStorage() throws Exception {
        return ResponseEntity.ok(storageService.listStorageFiles());
    }

    // Import a single file from storage to incoming
    @PostMapping("/import-storage")
    public ResponseEntity<Map<String, Object>> importFromStorage(@RequestParam("fileName") String fileName) throws Exception {
        try {
            Map<String, Object> result = storageService.importFromStorage(fileName);
            auditLogService.logActivity(
                "system", // TODO: Get actual ops user email from security context
                "Ops",
                "FILE_IMPORTED",
                "Ops user imported file from storage: " + fileName,
                "success"
            );
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            auditLogService.logActivity(
                "system",
                "Ops",
                "FILE_IMPORT_FAILED",
                "Failed to import file from storage: " + fileName + ". Error: " + e.getMessage(),
                "failed"
            );
            throw e;
        }
    }
}
